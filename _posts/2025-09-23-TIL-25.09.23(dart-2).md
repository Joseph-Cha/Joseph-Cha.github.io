---
title: "Today I Learned 7회차(1) - Dart 프로그래밍 기초 2회차"
date: 2025-09-23T00:00:00-00:00
categories:
  - TIL
tags:
  - TIL
---

## 함수형 프로그래밍에서 많이 사용하는 함수

### 형변환 함수
* toString(): 값을 문자열로
* int.parse(''): String 타입의 값을 int 타입으로
* double.parse(''): String 타입의 값을 double 타입으로
* toList(): Collection 타입의 값을 List 타입으로 형 변환
  ```dart
  Set<String> fruitSet = {'사과', '오렌지', '수박'};
  var fruitList = fruitSet.toList();
  print(fruitList); // [사과, 오렌지, 수박]
  print(fruitList.runtimeType); // List<String>
  ```
  * map은 사용 x
* toSet(): 특정 Collection 타입의 값을 Set 타입으로 변환한 값을 반환해요.
  ```dart
  List<String> fruitList = ['사과', '오렌지', '수박'];
  var fruitSet = fruitList.toSet();
  print(fruitSet); // {사과, 오렌지, 수박}
  print(fruitSet.runtimeType); // Set<String>
  ```
* asMap(): 특정 Collection 타입의 값을 Map 타입으로 변환한 값을 반환해요.
  ```dart
  List<String> fruitList = ['사과', '오렌지', '수박'];
  var fruitMap = fruitList.asMap();
  print(fruitMap); // {0: 사과, 1: 오렌지, 2: 수박}
  ```
  
  * List 의 Index 가 Map 의 키로, List 의 값이 Map 의 값으로 할당돼요.
  * Map 의 키는 고유하다고 했죠 ? List 의 Index 도 고유하니까 안성맞춤 👍🏼
  
  ```dart
  List<String> fruitList = ['사과', '오렌지', '수박', '사과'];
  var fruitMap = fruitList.asMap();
  print(fruitMap); // {0: 사과, 1: 오렌지, 2: 수박, 3: 사과}
  ```
  * Map 의 값은 중복되어도 된다고 했죠 ? 그래서 중복값이 적용되었나 보군요 !
  * List -> Map을 바꿀 때 index를 key 값으로 두고 List의 값들이 value에 위치하게 된다.
  * **Set은 index가 없기 때문에 Map으로 곧바로 캐스팅이 안됨** -> Set을 List로 변경 후 Map으로 변경하면 가능!

### 고차 함수

Collection 타입의 데이터에 있는 요소를 처리하거나 변환할 때 사용

**종류**

* map(): 
  * Collection 타입인 데이터의 각 요소에 특정 함수를 적용한 새로운 Collection 타입의 데이터를 반환해요.
  ```dart
  List<String> fruitList = ['사과', '오렌지', '수박'];
  var delicious = fruitList.map((fruit) {
    var word = '맛있는 ';
    word += fruit;
    return word;
  });
  print(delicious); // (맛있는 사과, 맛있는 오렌지, 맛있는 수박)
  ```
  ```dart
  Set<String> carSet = {'BMW', '현대', '기아'};
  var goodCar = carSet.map((car) {
    return '짱 멋진 $car';
  });
  print(goodCar); // (짱 멋진 BMW, 짱 멋진 현대, 짱 멋진 기아)
  ```
  ```dart
  List<int> numbers = [1, 2, 3, 4, 5];
  var doubledNumbers = numbers.map((n) => n * 2);
  print(doubledNumbers); // (2, 4, 6, 8, 10)
  ```

* where(): 
  * Collection 타입의 데이터에 있는 각 요소들을 특정 조건에 넣었을 때 **참인 요소들만 필터링**한 새로운 Collection 타입의 데이터를 반환해요.

  ```dart
  List<int> numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
  var result = numbers.where((number) {
	  return number > 5;
  });
  print(result); // (6, 7, 8, 9, 10)
  ```
  ```dart
  List<int> numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
  var result = numbers.where((n) => n > 5);
  print(result); // (6, 7, 8, 9, 10)
  ```

* firstWhere():
  * Collection 타입의 데이터에 있는 각 요소들을 특정 조건에 넣었을 때 **참인 요소들 중 첫번째 요소**를 반환해요.
  * firstWhere(([매개변수]) { return [조건식] });
  * firstWhere(([매개변수]) => [조건식] );

* firstWhere():
  * Collection 타입의 데이터에 있는 각 요소들을 특정 조건에 넣었을 때 **참인 요소들 중 마지막 요소**를 반환해요.

* reduce():
  * Collection 타입의 데이터에 있는 요소들을 **하나의 값**으로 결합해요.
  
  ```dart
  List<int> numbers = [1, 2, 3, 4, 5];
  var result = numbers.reduce((a, b) { // 15
    return a + b;
  });
  ```

* fold():
  * Collection 타입의 데이터에 있는 요소들을 하나의 값으로 결합해요.
  ```dart
  List<int> numbers = [1, 2, 3, 4, 5];
  var result = numbers.fold(1, (a, b) { // 16
    return a + b 
  });
  ```
  * 초기값(1)을 할당 후 각 요소들의 값을 하나로 결합
  
  ```dart
  List<int> numbers = [1, 2, 3, 4, 5];
  var result = numbers.fold('', (a, b) => '$a' + '$b');
  print(result); // 12345
  print(result.runtimeType); // String
  ```
  * 초기값 타입과 리턴 타입을 잘 맞추면 새로운 타입으로 형변환이 가능

* any():Collection 타입의 데이터에 있는 요소 중 **하나라도 주어진 조건을 만족**하면 true 를 반환해요.
  ```dart
  List<int> numbers = [1, 2, 3, 4, 5];
  var result = numbers.any((number) { // 결과 값도 boolean 타입
	  return number.isEven; // boolean 타입 반환
  });
  print(result); // true
  ```

  ```dart
  List<int> numbers = [1, 2, 3, 4, 5];
  var result = numbers.any((n) => n.isEven);
  print(result); // true
  ```

* every(): Collection 타입의 데이터에 있는 **모든 요소가 주어진 조건을 만족**하면 true 를 반환해요.
  ```dart
  List<int> numbers = [1, 2, 3, 4, 5];
  var result = numbers.every((number) {
    return number > 0;
  });
  print(result); // true
  ```
  
  ```dart
  List<int> numbers = [1, 2, 3, 4, 5];
  var result = numbers.any((number) => number > 0);
  print(result); // true
  ```

* takeWhile(): Collection 타입의 데이터에 있는 요소들에서 조건에 맞는 요소를 연속적으로 가져오다가, 조건에 맞지 않는 첫 번째 요소를 만나는 순간 작업을 멈추고 반환합니다.

  ```dart
  List<int> numbers = [1, 2, 3, 4, 5, 6];
  var result = numbers.takeWhile((number) {
  return number < 4;
  });
  print(result); // (1, 2, 3)
  ```

  ```dart
  List<int> numbers = [1, 2, 3, 4, 5, 6];
  var result = numbers.takeWhile((number) => number < 4);
  print(result); // (1, 2, 3)
  ```

* skipWhile(): Collection 타입의 데이터에 있는 요소들에서 조건에 맞는 요소를 연속적으로 건너뛰다가, 조건에 맞지 않는 첫 번째 요소를 만나는 순간 작업을 멈추고 이후 모든 요소들을 반환합니다.

  ```dart
  List<int> numbers = [1, 2, 3, 4, 5, 6];
  var result = numbers.skipWhile((number) {
  return number < 4;
  });
  print(result); // (4, 5, 6)
  ```
  ```dart
  List<int> numbers = [1, 2, 3, 4, 5, 6];
  var result = numbers.takeWhile((number) => number.isOdd);
  print(result); // (2, 3, 4, 5, 6)
  ```

## 객체 지향 프로그래밍과 Dart(1) - 클래스와 속성

**속성**

* 인스턴스 변수: 객체 에 속해 있는 변수
* 지역 변수: 특정 코드 블록 안에 선언된 변수
* 정적 변수

## 객체 지향 프로그래밍와 Dart(2) - 클래스와 메서드
* 메서드와 함수의 차이
  * 메서드: 클래스에 종속됨
  * 함수: 클래스와 관련 없이 동작

* 종류
  * 인스턴스 메서드
  * 정적 메서드
  * 생성자
    * 인스턴스 변수가 있다면 기본 생성자에서 모두 초기화를 시켜줘야 한다.
    * 매개변수 생성자
      ```dart
      // dart만의 타입인듯
      class Car {
        String name;
        List<String> models;
        
        Car(this.name, this.models);
      }
      ```
      ```dart
      // cpp 형태의 생성자도 지원
      class Car {
        String name;
        List<String> models;

        Car(String name, List<String> models)
            : this.name = name,
              this.models = models;
      }
      ```
      ```dart
      // java 스타일도 지원
      class Car {
        String name = '';
        List<String> models = [];

        Car(String name, List<String> models) {
          this.name = name;
          this.models = models;
        }
      }
    
    * 네임드 생성자: 클래스 메서드와 같은 형식으로 호출하는 생성자
      * [클래스 이름].[메서드 이름]([타입] [매개변수 이름]) : this.변수;
      ```dart
      class Car {
        String name;
        List<String> models;

        Car.fromList(List values)
            : this.name = values[0],
              this.models = values[1];
      }
      ```
      ```dart
      class Car {
        String name;
        List<String> models;

        Car.fromList(List values)
            : this.name = values[0],
              this.models = values[1];

        void speakName() {
          print('저희는 $name 입니다 !');
        }

        void speakModels() {
          print('$models 모델을 가지고 있습니다 !');
        }
      }

      void main() {
        Car car = Car.fromList([
          'BMW',
          ['320i', '340i', 'M3']
        ]);
        car.speakName(); // 저희는 BMW 입니다 !
        car.speakModels(); // [320i, 340i, M3] 모델을 가지고 있습니다 !
      }
      ```

* 제네릭 클래스
  ```dart
  class Box<T> {
    T value;

    Box(this.value);

    T getValue() {
      return value;
    }
  }
  ```

## 객체 지향 프로그래밍과 Dart(3) - 객체 지향과 상속

### 상속

* super 를 통해 자식 클래스 가 부모 클래스 의 속성 과 메서드 를 사용할 수 있어요.
* 자식 클래스 는 상속 받은 속성 과 메서드 를 재정의 (Overriding) 하거나 기능을 확장할 수 있어요.
* 근데요 .. 어떤 클래스 는 상속 당하지 (?) 않게 하고 싶을 때는 final 을 사용하면 돼요
  ```dart
  final class Person {
    void eat() {
      print('냠냠 !');
    }
  }

  class Student extends Person {
    // Error: The type 'Student' must be 'base', 'final' or 'sealed' because the supertype 'Person' is 'final'.
  }
  ```

**extends와 implements 차이**
* extends: 클래스 상속을 의미합니다. 부모 클래스의 모든 멤버(메서드와 속성)를 자식 클래스가 물려받아 사용할 수 있게 해줍니다.
* implements: 인터페이스 구현을 의미합니다. 


| 구분 | `extends` | `implements` |
| :--- | :--- | :--- |
| **목적** | 클래스 확장 및 **코드 재사용** | 인터페이스 구현 및 **규격 준수** |
| **코드** | 부모의 구현된 코드를 물려받음 | 부모의 구현된 코드는 물려받지 않음 |
| **의무** | 메서드 재정의는 선택 사항 | 모든 메서드를 반드시 재정의해야 함 |
| **개수** | 단일 상속만 가능 | 다중 구현이 가능 |

## 예외 처리로 단단한 코드 만들기

### 예외
**종류**
* DeferredLoadException: 필요한 시점에 로드되도록 설정한 라이브러리가 로드되지 못 했을 때 발생해요.
* FormatException: 데이터가 처리 가능한 형태가 아니어서 데이터를 처리하기 어려울 때 발생해요.
* IOException: 입출력 관련 동작을 하는 중에 발생하는 오류 🚨
  * FileSystemException
  * HttpException
  * ProcessException
  * SignalException
  * SocketException
  * StdinException
  * StdoutException
  * TlsException
  * WebSocketException
* OSError: 운영체제 레벨에서 발생하는 오류 🥹
* TimeoutException: 비동기 결과를 기다리는 동안 특정 시간이 초과되었을 때 발생해요.
* 사용자가 직접 정의한 예외:
  ```dart
  class AgeException implements Exception {
    final String? message;
    
    AgeException(this.message);
    
    @override
    String toString() => message ?? 'AgeException 이 발생했어요 !';
  }
  ```

**관련 키워드**

* try
* catch
* on: try 의 코드 블록에서 발생할 수 있는 예외 중 **특정 타입의 예외**를 다루는 부분
  ```dart
  on IOException catch (e) {
    // IOException 이 발생했을 때 실행할 코드
  }
  ```
* finally

### 오류(Error)

**종류**

* ArgumentError
* AssertionError
  ```dart
  void checkAge(int age) {
    assert(age > 0, 'Age must be positive');
  }

  void main() {
    checkAge(-5); // AssertionError 발생
  }
  ```
  ```dart
  assert(text != null);
  assert(number < 100, '100 이상이면 안 돼요 !');
  ```
* RangeError: 허용되지 않는 범위의 값이 매개변수로 전달되었을 때 발생해요.
* IndexError
* NoSuchMethodError: 함수 나 메서드 를 실행할 수 없는 경우에 발생해요.
* OutOfMemoryError
* StackOverflowError
* StateError: 객체의 현재 상태로는 특정 동작 수행이 불가능한 경우에 발생해요.
  ```dart
  List<int> numbers = [];
  print(numbers.first);
  ```
* TypeError
* UnimplementedError
* UnsupportedError: 객체를 통해 실행될 수 없는 동작일 때 발생해요.

## 예외 vs 오류

- **예외** 는 코드가 논리적으로 맞지 않거나 적절하지 않은 값이 입력되었을 때 발생하고,
- **오류** 는 주로 시스템에 문제가 생겼을 때 (ex. 메모리 부족) 발생해요.

- **예외** 는 예상할 수 있지만,
- **오류** 는 예상할 수 없어요.

- **예외** 는 `try-catch` 를 통해 처리할 수 있지만,
- **오류** 는 발생을 예상할 수 없기 때문에 처리할 수 없어요.


## 라이브러리를 이용해 확장하기

### **모든 플랫폼에서 사용 가능한 라이브러리**
* dart:core
* dart:async
* dart:collection
* dart:convert
* dart:developer
* dart:math

### **Native platform 에서 사용 가능한 라이브러리**
* dart:ffi: C API 를 사용할 수 있도록 하는 기능을 제공해요.
* dart:io

### **Web platform 에서 사용 가능한 라이브러리**
* package:web
* dart:js_interop
* dart:html

### **Dart SDK 에 포함되어 있지 않은 라이브러리**

Pub.dev 에서 다양한 외부 라이브러리를 쉽게 찾아서 사용할 수 있어요 🤩

**많이 쓰이는 라이브러리**
* cupertino_icons
* intl: 번역, 날짜 포맷팅, 숫자 포맷팅 등 국제화와 현지화 기능을 제공해요.
* shared_preferences: iOS 와 macOS 에서 사용하는 NSUserDefaults,Android 에서 사용하는 SharedPreferences 와 같은 역할을 해요.
* url_launcher
* image_picker: iOS 와 Android 에서 사진 다루는 기능을 제공해요.
* firebase_core
* firebase_auth
* google_fonts
* permission_handler: iOS 와 Android 의 권한을 다루는 기능을 제공해요.
* custom_lint: Lint 규칙을 쉽게 적용할 수 있도록 해주는 기능을 제공해요.
* flutter_svg: SVG 를 렌더링하기 위한 기능을 제공해요.
* cached_network_image: 네트워크를 통해 사진을 받아오고, 캐싱하는 기능을 제공해요.
* flutter_local_notifications: 로컬 알림을 다루는 기능 (ex. 알림 표시, 알림 예약) 을 제공해요.
* path_provider
* geolocator: iOS 와 Android 에서 위치를 다루기 위한 기능을 제공해요.
* dio: HTTP 네트워크 사용을 위한 기능을 제공해요.

보통 pub.dev 에 있는 외부 라이브러리를 가져올 때 package: 접두사가 붙어요.

**특징**

as 를 통해 라이브러리에 별칭을 부여할 수 있어요.
```dart
import 'package:http/http.dart' as http;
```

show 를 통해 라이브러리에서 필요한 부분만 선택적으로 가져올 수 있어요.
```dart
import 'package:lib1/lib1.dart' show foo;
```

hide 를 통해 라이브러리의 특정 부분을 제외하고 가져올 수 있어요.
```dart
import 'package:lib2/lib2.dart' hide foo;
```

deferred as 를 통해 라이브러리가 필요한 시점에 로드되도록 할 수 있어요.
* 모든 플랫폼에서 지원하는 것은 아니고, Web platform 에서만 지원

```dart
import 'package:greetings/hello.dart' deferred as hello;

Future<void> greet() async {
  await hello.loadLibrary();
  hello.printGreeting();
}
```

## 비동기 프로그래밍과 Dart

시간이 오래 걸리는 작업인 경우 결과값이 나오는 동안 cpu 블럭을 막기 위해서 비동기 동작을 실행하여 효율성을 챙겨준다.

대표적으로 아래 케이스 일 때 사용한다.

* 파일로부터 데이터를 읽을 때
* 데이터 베이스에 데이터를 쓸 때
* 네트워크를 통해 데이터를 불러올 때

### Future

작업이 성공적으로 완료되었을 때 해당 결과값을 반환하고, 실행을 종료

```dart
Future<String> introduce(String name) async {
	print('$name의 자기소개 시작 !');
  
  await Future.delayed(Duration(seconds: 2), () {
    print('안녕 ? 나는 $name ~');
  });
	
	print('$name의 자기소개 끝 !');
  
  return '이름은 $name ~';
}

void main() async {
  var riverfuture = await introduce('강미래');
  var riverpresent = await introduce('강현재');
  print('나의 $riverfuture 너의 $riverpresent');
}

/*
강미래의 자기소개 시작 !
안녕 ? 나는 강미래 ~
강미래의 자기소개 끝 !
강현재의 자기소개 시작 !
안녕 ? 나는 강현재 ~
강현재의 자기소개 끝 !
나의 이름은 강미래 ~ 너의 이름은 강현재 ~
*/
```

- 하지만 .. 이 `Future` 에는 한계가 있어요 🥺
  - 하나의 작업당 결과값을 1번만 받을 수 있답니다 .. 일회용이랄까요 ?
  - 하나의 작업에 결과값이 여러 번 나오는 경우가 있을 수 있잖아요 !
  - 이러한 한계를 극복하기 위해서 `Stream` 님이 등장하십니다

### Stream

시간에 따라 연속적인 데이터 흐름을 제공해요.
한 번에 하나의 값이 아닌 여러 값을 비동기적으로 받을 수 있어요.

```dart
Stream<int> emitNumbers(int first) async* {
  for (var i = first; i >= 0; i--) {
    yield i;
    
    await Future.delayed(Duration(seconds: 1));
  }
}

void main() {
  emitNumbers(10).listen((number) {
    print(number);
  });
}

/*
10
9
8
7
6
5
4
3
2
1
0
*/
```