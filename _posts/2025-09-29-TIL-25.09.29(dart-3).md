---
title: "📚 Today I Learned 11회차 - Dart with 키워드 💡"
date: 2025-09-29T00:00:00-00:00
categories:
  - TIL
  - Dart
tags:
  - TIL
  - Dart
  - Mixin
  - with

---


# 📖 Dart의 with 키워드

## 🎯 학습 목표
- **`extends`(상속)와 `with`(믹스인)의 차이점** 이해하기
- **Mixin의 정의와 사용법** 익히기
- **캐스팅과 타입 검사** 원리 파악하기
- **코드 재사용성을 높이는 믹스인의 활용법** 학습하기

## 📚 주요 내용

### ⭐ `extends`(상속) vs `with`(믹스인)

`with`를 이해하려면 먼저 `extends`(상속)와의 차이점을 아는 것이 중요합니다.

#### **1. `extends` (상속) 🧬**

`extends`는 **"\~이다" (is a)** 관계를 나타냅니다. 부모와 자식 관계처럼, 자식 클래스는 부모 클래스의 모든 것을 물려받습니다. 이는 클래스의 **근본적인 정체성**을 결정합니다.

  * 예시: `class Dog extends Animal { ... }`
      * "개는 **동물이다**." (Dog **is an** Animal.)
  * 특징: Dart에서는 **단 하나의 클래스만 `extends` 할 수 있습니다.** (부모는 하나)

#### **2. `with` (믹스인) 🚀**

`with`는 **"\~를 할 수 있다" (can do)** 관계를 나타냅니다. 상속처럼 정체성을 물려받는 것이 아니라, 특정 **기능(능력)만 쏙 가져와서 장착**하는 개념입니다.

  * **비유:** 자동차에 '터보 엔진'이나 '네비게이션' 같은 부품을 추가로 장착하는 것과 같습니다. 자동차의 본질(`extends Vehicle`)은 변하지 않지만, 새로운 능력(`with Turbo, with Navigation`)이 생기는 것이죠.
  * 특징: **여러 개의 기능을 `with` 키워드 뒤에 쉼표(,)로 구분하여 장착할 수 있습니다.**

-----

### ⚡ `with` 키워드 사용법과 예시

`with`는 이렇게 '기능 덩어리'인 **Mixin**을 클래스에 적용할 때 사용됩니다.

간단한 예시를 들어보겠습니다. '날 수 있는' 능력과 '헤엄칠 수 있는' 능력을 Mixin으로 만들어 보겠습니다.

**1. 능력(Mixin) 정의하기**
`mixin` 키워드를 사용해 재사용할 기능들을 정의합니다.

```dart
// 나는 능력을 정의
mixin CanFly {
  void fly() {
    print("하늘을 납니다. 훨훨~");
  }
}

// 헤엄치는 능력을 정의
mixin CanSwim {
  void swim() {
    print("물에서 헤엄칩니다. 첨벙첨벙!");
  }
}
```

**2. 클래스에 능력(`with`) 장착하기**

이제 이 능력들을 여러 클래스에 `with` 키워드로 장착해 보겠습니다.

```dart
// '새'는 기본적으로 '동물'이며, '나는 능력'을 가집니다.
class Bird extends Animal with CanFly {
  // Bird 클래스는 이제 fly() 메소드를 사용할 수 있습니다.
}

// '오리'는 '동물'이며, '나는 능력'과 '헤엄치는 능력'을 모두 가집니다.
class Duck extends Animal with CanFly, CanSwim {
  // Duck 클래스는 이제 fly()와 swim() 메소드를 모두 사용할 수 있습니다.
}

// '물고기'는 '동물'이며, '헤엄치는 능력'만 가집니다.
class Fish extends Animal with CanSwim {
  // Fish 클래스는 이제 swim() 메소드를 사용할 수 있습니다.
}

void main() {
  var duck = Duck();
  duck.fly();   // 출력: 하늘을 납니다. 훨훨~
  duck.swim();  // 출력: 물에서 헤엄칩니다. 첨벙첨벙!

  var fish = Fish();
  fish.swim();  // 출력: 물에서 헤엄칩니다. 첨벙첨벙!
  // fish.fly(); // 에러! Fish는 CanFly 능력이 없습니다.
}
```

이처럼 `with`를 사용하면 상속 관계와 얽히지 않고, 원하는 클래스에 필요한 기능만 자유롭게 추가하여 코드의 재사용성을 극대화할 수 있습니다.

-----

### 🔍 이전 설명에 다시 적용해보기

이제 `TickerProviderStateMixin` 설명에 나왔던 코드를 다시 보면 완벽하게 이해할 수 있습니다.

`class _MyAnimationState extends State<MyAnimation> with TickerProviderStateMixin { ... }`

  * `extends State<MyAnimation>`
      * 이 클래스의 정체성은 `State`이다. ("나는 `MyAnimation`의 상태 객체**이다**.")
  * `with TickerProviderStateMixin`
      * 그리고 나는 `TickerProviderStateMixin`이 제공하는 **능력**을 추가로 장착했다. ("나는 Ticker를 제공**할 수 있다**.")

### 📋 핵심 개념 정리

| 구분 | **`extends` (상속)** | **`with` (믹스인)** |
| :--- | :--- | :--- |
| **관계** | **is a** (A는 B이다) | **can do** (A는 B를 할 수 있다) |
| **개수** | 단 하나만 가능 | **여러 개 가능** |
| **목적** | 부모-자식 관계의 핵심 정체성 정의 | 여러 클래스에 걸쳐 **코드(기능)를 재사용** |
| **비유** | 혈연, 가문 🧬 | 스킬 습득, 장비 장착 🚀 |

## 💻 실습 및 예제

### 🤔 **질문**: with으로 상속받은 클래스로 casting은 안되는 걸까?

**결론부터 말씀드리면, 네, 가능합니다.**

`with` 키워드로 추가된 믹스인(Mixin)은 해당 클래스가 그 믹스인의 **타입을 구현(implements)하는 것으로 간주**됩니다. 따라서 그 믹스인 타입으로 캐스팅(형변환)하거나 타입 검사를 할 수 있습니다.

-----

### 💡 `with`와 `implements`의 숨겨진 관계

이것이 가능한 이유를 이해하려면 Dart가 `with`를 어떻게 처리하는지 알아야 합니다.

`class MyClass with MyMixin { ... }`

위 코드는 사실상 Dart 내부적으로 아래와 같이 동작합니다.

`class MyClass implements MyMixin { ... }`

`with`는 `implements`(인터페이스 구현)의 특별한 버전이라고 생각할 수 있습니다. `implements`는 "이런이런 기능들을 가지고 있다고 약속할게"라고 선언만 하는 것이라 모든 메소드를 직접 구현해야 하지만, `with`는 **선언과 동시에 믹스인에 이미 작성된 기능들을 그대로 가져와서 자동으로 구현**해줍니다.

결국, `with MyMixin`을 사용한 클래스는 `MyMixin`의 \*\*하위 타입(subtype)\*\*이 되므로, 타입 검사(`is`)와 캐스팅(`as`)이 모두 가능해지는 것입니다.

-----

### 💻 타입 캐스팅 실습

이전 답변에서 사용했던 `CanFly`, `CanSwim` 예제로 직접 확인해 보겠습니다.

```dart
// 능력(Mixin) 정의
mixin CanFly {
  void fly() => print("하늘을 납니다. 훨훨~");
}

mixin CanSwim {
  void swim() => print("물에서 헤엄칩니다. 첨벙첨벙!");
}

// '오리'는 나는 능력과 헤엄치는 능력을 모두 가짐
class Duck with CanFly, CanSwim {}

// 비행을 시키는 함수 (CanFly 타입을 매개변수로 받음)
void makeItFly(CanFly flyer) {
  print("${flyer.runtimeType} 객체가 날아갑니다.");
  flyer.fly();
}

void main() {
  var duck = Duck();

  // 1. 타입 검사 (is 키워드)
  // duck은 CanFly 타입인가? -> true
  print('duck is CanFly: ${duck is CanFly}');
  // duck은 CanSwim 타입인가? -> true
  print('duck is CanSwim: ${duck is CanSwim}');
  // duck은 String 타입인가? -> false
  print('duck is String: ${duck is String}');

  print('---');

  // 2. 명시적 캐스팅 (as 키워드)
  // duck 객체를 CanFly 타입으로 간주하여 flyer 변수에 할당
  CanFly flyer = duck as CanFly;
  flyer.fly();

  print('---');
  
  // 3. 실용적인 예시: 함수에 전달하기
  // makeItFly 함수는 CanFly 타입을 요구하는데, duck은 CanFly의 하위 타입이므로 전달 가능
  makeItFly(duck);
}
```

#### **실행 결과:**

```
duck is CanFly: true
duck is CanSwim: true
duck is String: false
---
하늘을 납니다. 훨훨~
---
Duck 객체가 날아갑니다.
하늘을 납니다. 훨훨~
```

-----

### 🎯 타입 캐스팅 핵심 정리

  * **캐스팅 가능하다:** `with`로 추가한 믹스인은 해당 클래스의 타입 중 하나로 인정됩니다.
  * **이유:** `with`는 믹스인을 \*\*구현(implements)\*\*하는 것과 같아서, 클래스는 믹스인의 하위 타입이 되기 때문입니다.
  * **활용:** 이 특징 덕분에 특정 기능(믹스인)을 가진 객체들만 인자로 받는 유연한 함수를 작성할 수 있습니다. `makeItFly(CanFly flyer)` 함수가 `Duck`뿐만 아니라 `with CanFly`를 사용한 어떤 객체(`Bird`, `Airplane` 등)라도 받을 수 있는 것처럼 말이죠.

  Q) 기존에 c#을 써왔던 입장에서 생각을 해보면, interface와 같이 상속 후 구현(implenment)은 아닌 것 같고, abstract와 비슷한 느낌인데, 그러면 abstract에서 virtual로 상속 받은 메서드를 override 하는 방식으로 재정의 후 사용이 가능한 걸까? 그리고 mixin 은 메서드만 기능으로 장착할 수 있는 걸까?

  C\# 개발자 입장에서 정말 좋은 질문입니다. C\#의 `interface`, `abstract class`, `virtual`/`override` 개념과 Dart의 `mixin`을 비교하면 그 차이점을 명확히 이해할 수 있습니다.

두 가지 질문에 대해 나눠서 답변해 드릴게요.

-----

### ⚡ 1. Mixin 메서드 재정의(Override)와 동작 방식

결론부터 말씀드리면, **네, 믹스인의 메서드를 재정의(override)할 수 있습니다.** 하지만 C\#의 `abstract class`와 `virtual`/`override` 동작 방식과는 근본적인 차이가 있습니다.

C\#의 개념과 비교하여 믹스인을 이해하는 가장 좋은 비유는 다음과 같습니다.

  * **`interface` (C\#):** \*\*"설계도"\*\*에 가깝습니다. 어떤 기능들이 있어야 하는지 '약속'만 하고, 실제 구현은 클래스에서 모두 해야 합니다.
  * **`abstract class` (C\#):** \*\*"반쯤 지어진 집"\*\*과 같습니다. 일부 기능(`virtual` 또는 일반 메서드)은 이미 구현되어 있고, 일부(`abstract` 메서드)는 비어 있어서 상속받는 클래스가 반드시 완성해야 합니다.
  * **`mixin` (Dart):** \*\*"조립식 부품" 또는 "플러그인"\*\*에 가깝습니다. 이미 완성된 기능 덩어리를 가져와 내 클래스에 그대로 '장착'하는 개념입니다.

#### **동작 방식의 차이: 상속 체인 vs 우선순위**

C\#의 `override`는 부모 클래스(`base`)의 `virtual` 메서드를 자식 클래스에서 재정의하는, 명확한 상속 계층 구조 안에서 동작합니다.

반면, 믹스인은 \*\*"우선순위"\*\*에 따라 적용됩니다. 여러 믹스인을 사용하거나 클래스 자체에 같은 이름의 메서드가 있다면, 정해진 규칙에 따라 어떤 메서드를 사용할지 결정합니다.

**규칙: `class` 선언부의 오른쪽에서 왼쪽 순서로 적용된다.**

`class MyRobot extends Machine with Walker, Runner { ... }`

만약 `Walker`와 `Runner` 믹스인 모두에 `move()`라는 메서드가 있다면, `MyRobot` 인스턴스에서 `move()`를 호출하면 **가장 마지막에 `with`로 추가된 `Runner`의 `move()`가 실행됩니다.**

그리고 만약 `MyRobot` 클래스 자체에서 `move()` 메서드를 `override`하면, **`MyRobot`의 `move()`가 최우선 순위**를 갖게 됩니다.

#### **코드 예시**

```dart
mixin Walker {
  void move() {
    print("두 발로 걷습니다.");
  }
}

mixin Runner {
  void move() {
    print("빠르게 달립니다!"); // Walker의 move()와 이름이 같음
  }
}

// 1. Runner의 move()가 우선순위를 가짐
class Robot with Walker, Runner {}

// 2. 클래스 자체의 move()가 최우선순위를 가짐
class AdvancedRobot with Walker, Runner {
  @override
  void move() {
    print("부스터를 켜고 날아갑니다!");
    // super.move(); // 호출 시 바로 위 우선순위인 Runner의 move()가 실행됨
  }
}

void main() {
  var robot = Robot();
  robot.move(); // 출력: 빠르게 달립니다!

  var advancedRobot = AdvancedRobot();
  advancedRobot.move(); // 출력: 부스터를 켜고 날아갑니다!
}
```

> **정리:** C\#의 `override`가 부모-자식 간의 수직적 재정의라면, Dart 믹스인의 재정의는 **클래스 자체의 구현이 믹스인의 구현을 덮어쓰는(우선하는) 방식**에 더 가깝습니다. `super` 키워드를 사용하면 바로 다음 우선순위의 믹스인 메서드를 호출할 수도 있습니다.

-----

### ⚡ 2. Mixin이 가질 수 있는 멤버

**아니요, 믹스인은 메서드뿐만 아니라 변수(프로퍼티), Getter/Setter 등도 포함할 수 있습니다.**

믹스인은 재사용 가능한 \*\*'코드 덩어리'\*\*이므로, 상태(state)를 저장하는 변수와 그 상태를 조작하는 행위(method)를 모두 가질 수 있습니다.

#### **코드 예시**

```dart
mixin BatteryManager {
  // 1. 변수 (프로퍼티)
  double _batteryLevel = 100.0;

  // 2. Getter
  double get batteryStatus => _batteryLevel;

  // 3. 메서드
  void usePower(double amount) {
    _batteryLevel -= amount;
    if (_batteryLevel < 0) {
      _batteryLevel = 0;
    }
    print("전력 사용! 현재 배터리: ${_batteryLevel.toStringAsFixed(1)}%");
  }

  void charge() {
    _batteryLevel = 100.0;
    print("충전 완료!");
  }
}

class Drone with BatteryManager {
  void fly() {
    print("드론 비행 시작...");
    usePower(15.5); // 믹스인의 메서드와 변수를 내 것처럼 사용
  }
}

void main() {
  var myDrone = Drone();
  myDrone.fly(); // 출력: 드론 비행 시작... -> 전력 사용! 현재 배터리: 84.5%
  
  // 믹스인의 Getter에도 접근 가능
  print("드론 배터리 상태: ${myDrone.batteryStatus}%"); // 출력: 드론 배터리 상태: 84.5%
}
```

이처럼 `BatteryManager` 믹스인은 배터리 잔량이라는 상태(`_batteryLevel`)와 관련 동작(`usePower`, `charge`)을 모두 포함하고 있으며, `Drone` 클래스는 이 기능들을 그대로 '장착'하여 사용할 수 있습니다.

### 🤔 **질문**: 왜 Mixin이 필요한가?

> **질문**: 왜 이런 구조가 필요한 걸까? 어차피 상속을 받아도 부모 클래스에 있는 기능들을 가지고 와서 사용할 수 있는데 말이지?

정말 좋은 질문입니다. 그 질문이야말로 믹스인(Mixin)의 존재 이유를 관통하는 핵심입니다.

결론부터 말씀드리면, 상속만으로는 해결하기 어려운 **'코드 중복' 문제**를 매우 유연하고 우아하게 해결하기 위해서입니다. 특히 **서로 다른 상속 계층에 있는 클래스들이 공통된 기능을 가져야 할 때** 믹스인의 진정한 가치가 드러납니다.

-----

### ⚠️ 상속만으로는 부족한 이유: "다이아몬드 문제"

대부분의 객체 지향 언어(C\#, Java, Dart 포함)는 **단일 상속**만 허용합니다. 즉, 하나의 클래스는 단 하나의 부모 클래스만 가질 수 있죠. 이 제약 때문에 문제가 발생합니다.

간단한 게임 캐릭터 예시를 들어보겠습니다.

  * `Character` 라는 최상위 부모 클래스가 있습니다.
  * `Knight` 와 `Magician` 은 `Character` 를 상속받습니다.
  * `Paladin` 이라는 새로운 캐릭터를 만들고 싶습니다. 팔라딘은 **기사의 능력(검술)과 마법사의 능력(치유 마법)을 모두** 가집니다.

**상속만 사용한다면 어떻게 해야 할까요?**

1.  `class Paladin extends Knight { ... }`
      * 이렇게 하면 기사의 능력은 물려받지만, 마법사의 능력은 받을 수 없습니다. 결국 `Magician` 클래스에 있던 치유 마법 코드를 `Paladin` 클래스에 **복사해서 붙여넣어야 합니다.**
2.  `class Paladin extends Magician { ... }`
      * 반대로 하면 검술 코드를 **복사해서 붙여넣어야 합니다.**

어떤 방법을 선택하든 **코드 중복**이 발생합니다. 나중에 치유 마법의 성능을 수정하려면 `Magician`과 `Paladin` 두 클래스를 모두 고쳐야 하는 끔찍한 상황이 생기죠.

이처럼 여러 부모의 특징을 동시에 물려받고 싶을 때 단일 상속의 한계로 인해 발생하는 문제를 \*\*"다이아몬드 문제(Diamond Problem)"\*\*라고 부릅니다.

> C\#에서는 이 문제를 `interface`로 일부 해결합니다. `IHasSwordSkills`, `IHasHealingMagic` 같은 인터페이스를 만들어 `Paladin`이 둘 다 구현(implements)하게 할 수 있죠. 하지만 인터페이스는 '무엇을 할 수 있는지'만 정의할 뿐, '어떻게 하는지'에 대한 **실제 코드(구현)를 제공하지 않기 때문에** 결국 코드 중복 문제는 여전히 남습니다.

-----

### ✅ 믹스인의 해결책: 기능의 조합(Composition)

믹스인은 이 다이아몬드 문제를 완벽하게 해결합니다. 핵심적인 능력들을 '부품'처럼 만들어두고, 필요한 클래스에 '장착'만 하면 됩니다.

**1. 능력(Mixin)을 정의합니다.**

```dart
mixin SwordSkills {
  void attackWithSword() => print("검으로 공격!");
}

mixin HealingMagic {
  void heal() => print("치유 마법 시전!");
}
```

**2. 필요한 클래스에 `with`로 장착합니다.**

```dart
class Character {}

// 기사는 검술 능력을 장착
class Knight extends Character with SwordSkills {}

// 마법사는 치유 마법 능력을 장착
class Magician extends Character with HealingMagic {}

// 팔라딘은 검술과 치유 마법 능력을 모두 장착
class Paladin extends Character with SwordSkills, HealingMagic {}
```

이제 `Paladin` 클래스는 코드를 단 한 줄도 복사하지 않고 `attackWithSword()`와 `heal()` 메서드를 모두 사용할 수 있습니다. 만약 치유 마법의 코드를 수정해야 한다면 `HealingMagic` 믹스인만 수정하면 됩니다. **코드 중복이 사라지고 유지보수가 매우 쉬워졌습니다.**

-----

### 📋 상속(`extends`) vs 믹스인(`with`)의 역할

| 구분 | **`extends` (상속)** | **`with` (믹스인)** |
| :--- | :--- | :--- |
| **관계** | **"is a"** (A는 B이다) | **"can do"** (A는 B를 할 수 있다) |
| **목적** | 클래스의 **핵심 정체성**을 정의 (수직적 관계) | 여러 클래스에 걸쳐 **공통 기능을 재사용** (수평적 추가) |
| **예시** | `Paladin` **is a** `Character`. | `Paladin` **can do** `SwordSkills` and `HealingMagic`. |

## 📝 마무리

### ✅ 오늘 배운 것
- **`extends` vs `with`**: 상속은 "is a" 관계, 믹스인은 "can do" 관계
- **Mixin 정의**: `mixin` 키워드로 재사용 가능한 기능 덩어리 생성
- **타입 캐스팅**: `with`로 추가한 믹스인으로 타입 캐스팅 가능
- **메서드 재정의**: 믹스인의 메서드를 클래스에서 오버라이드 가능
- **다양한 멤버**: 믹스인은 메서드뿐만 아니라 변수, getter/setter도 포함 가능
- **다이아몬드 문제 해결**: 단일 상속의 한계를 믹스인으로 극복

### 🚀 다음 계획
- **Flutter에서 Mixin 활용**: TickerProviderStateMixin 등 실제 사용 사례 학습
- **Advanced Mixin Pattern**: 복합 믹스인과 상속 체인 조합 연구
- **Performance**: 믹스인 사용 시 성능 고려사항 학습

> 💡 **핵심**: 믹스인은 상속을 대체하는 것이 아니라, 상속의 수직적 구조를 보완하는 **수평적 기능 조합**을 가능하게 하여 객체 지향 프로그래밍을 더욱 풍부하고 유연하게 만들어주는 핵심 도구입니다! 🧩