---
title: "Today I Learned"
date: 2025-09-15T19:30:00-00:00
categories:
  - TIL
tags:
  - TIL
---

오늘을 시작으로 TIL(Today I Learned) 작성을 시작하려고 한다.
대부분 Flutter와 관련된 내용이 주를 이루겠지만, 간간히 사업과 관련된 인사이트도 함께 정리해 볼 수 있으면 좋을 것 같다.

# Dart 기본 강의 수강

## 1. Why Flutter

- React Native를 선택하는 가장 큰 이유는 Code push를 활용 여부였다.
- Code Push를 사용하면 앱 심사 과정을 거치지 않아도 UI 업데이트와 같은 간단한 로직들을 배포된 서비스에 곧바로 적용할 수 있기 때문이다.
- 하지만 최근에 flutter에서도 Codepush와 같은 `shorebird` 서비스가 등장해서 code push와 동일한 기능을 제공해 주고 있다.

## 2. 함수

1. named 파라미터
    - 함수에서 named parameter를 사용하게 되면 호출할 당시 인자의 순서의 상관 없이 호출하여 사용 가능
    - optional
    - 함수 인자에서 { }를 사용했을 경우 required 아니면 optional 타입을 사용해야한다.
        - { }를 사용하다는 것 자체가 named 파라미터를 사용하는 함수를 의미한다.
    - named 파라미터의 반대는 positional 파라미터이다.
2. stateful widget
    - 위젯의 상태가 변경 가능함
3. setState 함수
    - build 함수를 다시 호출하는 기능을 동작
    - 즉, 화면을 다시 그리게 되면서 변경된 상태가 적용된다.

## 3. 동기 vs 비동기

- 동기
    - 한 작업이 완료될 때까지 다음 작업이 블록킹됨
- 비동기
    
    ```dart
    void main() {
      print('작업 1 시작');
      performTask();
      print('작업 1 완료');
    }
    
    Future<void> performTask() async {
      await Future.delayed(Duration(seconds: 2));
      print('작업 2 실행');
    }
    ```
    
    - C#을 기준으로 생각했을 때 Future 타입이 곧 Task로 보면 될 듯

<aside>
❓

async 키워드

- 함수에 async를 붙이면 비동기 함수가 됩니다.
- 비동기 함수는 항상 Future 객체를 반환되도록 설계 되어있습니다.
</aside>

<aside>
❓

await 키워드 

- await은 비동기 함수 내에서만 사용이 가능합니다.
- await은 Future가 완료될때가지 기다리며 완료되면 결과 값을 반환합니다.
- await은 비동기 코드를 동기 코드처럼 작성할 수 있게 해줍니다.
</aside>

## 4. 위젯트리

![image.png](../assets/images/TIL/2025-09-15-(1).png)

현재 샘플 앱의 위젯은 위와 같은 트리 구조로 나타낼 수 있다.

여기서 중요한 포인트는 위젯이 변경되었을 때 다시 그리는 UI 영역을 지정할 수가 있다는 점이다.

어찌보면 가장 간단한 방식은 MyApp이라는 최상단 위젯을 업데이트(setState)하는 것이데 이렇게 되면 굳이 변경되지 않아도 되는 UI도 변경을 해야하기 때문에 비효율적이다.

따라서 설계된 방식이 변경이 필요한 위젯의 영역만 stateful widget으로 변경하는 방식이다.

따라서 CardWidget을 업데이트할 때 Text Widget을 어떻게 업데이트 해줄 수 있을까?

상태 관리 라이브러리를 사용한다면, 손쉽게 변경이 가능하지만 아직 배우지는 않았기 때문에 어쩔 수 없이 상위 위젯이 새로 빌드 될 수 있도록 해줘야 한다.

Header에서 관리되고 있는 score와 count 변수가 이를 Home에도 할당을 해줘야 한다.

Home에서 score와 count 변수를 선언해 주고 이를 header 위젯으로 내려줘야한다.

CardBoard에서는 부모(여기서는 Home Widget)에게 이벤트 함수를 호출해야 한다.

즉, Home 위젯이 Card board의 이벤트를 받아서 Header 위젯에 정보를 전달해줘야한다.

```dart
  void onTapCard(int cardIndex) {
    print('$cardIndex 번째 카드를 선택하셨습니다.');
    if (instantFirstCard == -1) {
      instantFirstCard = cardIndex;
    } else {
      // 두번째 카드가 선택되었을때 로직 추가
      widget.updateTryCount(); // 왜 앞에 widget 가 붙을까?
      var firstCard = cards[instantFirstCard];
      var secondCard = cards[cardIndex];
      if (firstCard == secondCard) {
        print('짝이 맞았습니다.');
        instantFirstCard = -1;
      } else {
        resetInstantCards(instantFirstCard, cardIndex);
      }
    }
    setState(() {
      cardsFlippedState[cardIndex] = true;
    });
  }
```

CardBoards 위젯 생성 시 전달 받은 updateTryCount를 호출할 때 `widget`에서 호출하는 이유

→ CardBoards 클래스를 generic으로 상속 받은 _CardBoardsState에서 CardBoard 위젯에 접근하기 위해서 `widget`으로 접근이 가능하기 때문이다.

## <과제>

<aside>
❓

### 1. Score 값이 카드 짝 맞추기 성공하면 100씩 올리는 작업

Score 값을 100 씩 올리기 위해서는 먼저 Home에서 score를 header에 전달해 줄 수 있도록 header의 생성자에서 score를 입력 받을 수 있도록 해줘야 한다.

```dart
const Header({super.key, this.tryCount = 0, this.score = 0);
```

그리고 Home에서 생성하고 있는 CardBoard에서 Home에게 이벤트를 전달해 줄 수 있도록 Home의 함수 포인터를 CardBoard에 전달해 줘야 한다.

```dart
Expanded(
  child: CardBoards(
    updateTryCount: updateTryCount,
    updateScore: updateScore,
  ),
),
```

이어서 updateScore의 경우 아래와 같이 구현을 진행한다.

```dart
void updateScore() {
  setState(() {
    score += 100;
  });
}
```

끝으로 CardBoards에서 `onTapCard` 함수 내부에서 조건 만족 시 updateScore를 호출하면 끝!

```dart
void onTapCard(int cardIndex) {
  print('$cardIndex 번째 카드를 선택하셨습니다.');
  if (instantFirstCard == -1) {
    instantFirstCard = cardIndex;
  } else {
    widget.updateTryCount();
    var firstCard = cards[instantFirstCard];
    var secondCard = cards[cardIndex];
    if (firstCard == secondCard) {
      print('짝이 맞았습니다.');
      instantFirstCard = -1;
      widget.updateScore();
    } else {
      resetInstantCards(instantFirstCard, cardIndex);
    }
  }
}
```

</aside>

<aside>
❓

### 2. 새 게임 버튼을 누르면 모든 카드를 초기화 하고 점수와 시도 횟수를 0으로 변경

header에 우선 아래와 같이 TextButton을 추가한다.

```dart
Expanded(
  child: Container(
    margin: EdgeInsets.only(top: 10, bottom: 10, left: 5, right: 10),
    decoration: BoxDecoration(
      borderRadius: BorderRadius.circular(6),
      color: Color(0xffFF9999),
    ),
    child: TextButton(
        onPressed: onTabReset, child: Center(child: Text('리셋'))),
  ),
),
```

다만, 위젯의 상태를 현재는 Home에서 변경하는 구조로 잡혀 있기 때문에 현 구조를 유지하기 위해서 Home에서 Header에 이벤트를 전달해 줄 수 있도록 아래와 같이 Header 생성자에서 함수를 받을 수 있도록 구현한다.

```dart
const Header({super.key, this.tryCount = 0, this.score = 0, this.onNewGame});
```

이어서 Home에서 Header에 게임을 초기화 하는 작업을 수행하는 함수를 아래와 같이 전달해 준다.

```dart
class Home extends StatefulWidget {
  @override
  State<Home> createState() => _HomeState();
}

class _HomeState extends State<Home> {
  int tryCount = 0;
  int score = 0;

  void resetGame() {
    setState(() {
      tryCount = 0;
      score = 0;
    });
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      backgroundColor: const Color(0xffECE7E4),
      appBar: AppBar(
        title: const Text('짝맞추기 게임'),
        backgroundColor: const Color(0xff92CBFF),
      ),
      body: Padding(
        padding: EdgeInsets.all(20.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.stretch,
          children: [
          Header(
            tryCount: tryCount,
            score: score,
            onNewGame: resetGame,
          ),
            SizedBox(height: 20),
            Expanded(
              child: CardBoards(
                updateTryCount: updateTryCount,
                updateScore: updateScore,
              ),
            ),
          ],
        ),
      ),
    );
  }
}

```

위와 같이 구현을 하게 되면 Header에서 Button 클릭 시 Home에서 전달 받은 이벤트(`resetGame`)가 실행이 되어서 정상적으로 초기화 작업이 진행된다.

</aside>

## 5. 클래스

- late 키워드의 의미
    - 사용하는 시점에는 반드시 초기화가 되어 있을거라 가정하기 때문에 nullable 체크가 필요하지 않다.
    - 실제 로직에서 initState 함수에서 해당 변수를 초기화 해주고 있다.
    - 변수 초기화 시점을 뒤로 미루게 되면 화면이 뜨는 타이밍을 좀더 최적화할 수 있기 때문에 위젯에서 사용하는 무거운 변수는 이렇게 late 키워드를 활용하면 좋다.
    - 그리고 반드시 초기화를 해주고 사용해야 한다.
- List.generate 사용법 ㅊ
    
    ```dart
    List.generate(cardsValue.length, (index) {
      return CardModel(index: index, cardValue: cardsValue[index]);
    });
    ```