---
title: "📚 Today I Learned 7회차(1) - Dart 프로그래밍 기초 2회차 💡"
date: 2025-09-23T00:00:00-00:00
categories:
  - TIL
  - Programming
tags:
  - TIL
  - Dart
  - Flutter
  - Programming
---

# 📖 Dart 프로그래밍 기초 2회차

## 🎯 학습 목표
- **함수형 프로그래밍**의 핵심 함수들을 이해하고 활용할 수 있다
- **객체 지향 프로그래밍**의 클래스, 속성, 메서드 개념을 숙지한다
- **예외 처리**를 통해 안정적인 코드를 작성할 수 있다
- **비동기 프로그래밍**의 기본 개념을 파악한다

## 📚 주요 내용

### ⭐ 함수형 프로그래밍에서 많이 사용하는 함수

#### 🔄 형변환 함수
* **`toString()`**: 값을 문자열로 변환
* **`int.parse('')`**: String 타입의 값을 int 타입으로 변환
* **`double.parse('')`**: String 타입의 값을 double 타입으로 변환
* **`toList()`**: Collection 타입의 값을 List 타입으로 형 변환
  ```dart
  Set<String> fruitSet = {'사과', '오렌지', '수박'};
  var fruitList = fruitSet.toList();
  print(fruitList); // [사과, 오렌지, 수박]
  print(fruitList.runtimeType); // List<String>
  ```

> 💡 **주의**: Map 타입은 `toList()` 함수를 직접 사용할 수 없습니다.

* **`toSet()`**: 특정 Collection 타입의 값을 Set 타입으로 변환한 값을 반환
  ```dart
  List<String> fruitList = ['사과', '오렌지', '수박'];
  var fruitSet = fruitList.toSet();
  print(fruitSet); // {사과, 오렌지, 수박}
  print(fruitSet.runtimeType); // Set<String>
  ```
* **`asMap()`**: 특정 Collection 타입의 값을 Map 타입으로 변환한 값을 반환
  ```dart
  List<String> fruitList = ['사과', '오렌지', '수박'];
  var fruitMap = fruitList.asMap();
  print(fruitMap); // {0: 사과, 1: 오렌지, 2: 수박}
  ```
  
  > 💡 **핵심**: List의 Index가 Map의 키로, List의 값이 Map의 값으로 할당됩니다.
  > Map의 키는 고유하고 List의 Index도 고유하므로 완벽한 조합입니다! 👍🏼
  
  ```dart
  List<String> fruitList = ['사과', '오렌지', '수박', '사과'];
  var fruitMap = fruitList.asMap();
  print(fruitMap); // {0: 사과, 1: 오렌지, 2: 수박, 3: 사과}
  ```
  > ⚠️ **중요 포인트**:
  > - Map의 값은 중복이 허용되므로 List의 중복 값도 그대로 유지됩니다
  > - List → Map 변환 시 index가 key, List의 값이 value가 됩니다
  > - **Set은 index가 없어 직접 Map 변환 불가** → Set을 List로 먼저 변환 후 Map으로!

#### ⚡ 고차 함수

**Collection 타입의 데이터**에 있는 요소를 처리하거나 변환할 때 사용하는 강력한 함수들입니다.

**📋 주요 고차 함수 종류**

##### 🔄 **`map()`**
**Collection 타입인 데이터의 각 요소에 특정 함수를 적용**한 새로운 Collection 타입의 데이터를 반환합니다.
  ```dart
  List<String> fruitList = ['사과', '오렌지', '수박'];
  var delicious = fruitList.map((fruit) {
    var word = '맛있는 ';
    word += fruit;
    return word;
  });
  print(delicious); // (맛있는 사과, 맛있는 오렌지, 맛있는 수박)
  ```
  ```dart
  Set<String> carSet = {'BMW', '현대', '기아'};
  var goodCar = carSet.map((car) {
    return '짱 멋진 $car';
  });
  print(goodCar); // (짱 멋진 BMW, 짱 멋진 현대, 짱 멋진 기아)
  ```
  ```dart
  List<int> numbers = [1, 2, 3, 4, 5];
  var doubledNumbers = numbers.map((n) => n * 2);
  print(doubledNumbers); // (2, 4, 6, 8, 10)
  ```

##### 🔍 **`where()`**
**Collection 타입의 데이터에서 특정 조건을 만족하는 요소들만 필터링**한 새로운 Collection 타입의 데이터를 반환합니다.

  ```dart
  List<int> numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
  var result = numbers.where((number) {
	  return number > 5;
  });
  print(result); // (6, 7, 8, 9, 10)
  ```
  ```dart
  List<int> numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
  var result = numbers.where((n) => n > 5);
  print(result); // (6, 7, 8, 9, 10)
  ```

##### 🎯 **`firstWhere()`** & **`lastWhere()`**
**Collection 타입의 데이터에서 특정 조건을 만족하는 첫 번째/마지막 요소**를 반환합니다.

```dart
// 문법 형태
firstWhere(([매개변수]) { return [조건식]; });
firstWhere(([매개변수]) => [조건식]);
```


##### 🔗 **`reduce()`**
**Collection 타입의 데이터에 있는 요소들을 하나의 값으로 결합**합니다.
  
  ```dart
  List<int> numbers = [1, 2, 3, 4, 5];
  var result = numbers.reduce((a, b) { // 15
    return a + b;
  });
  ```

##### 📦 **`fold()`**
**Collection 타입의 데이터에 있는 요소들을 하나의 값으로 결합**합니다. `reduce()`와 달리 **초기값을 설정**할 수 있습니다.
  ```dart
  List<int> numbers = [1, 2, 3, 4, 5];
  var result = numbers.fold(1, (a, b) { // 16
    return a + b 
  });
  ```
  > 💡 **핵심 차이점**: 초기값(1)을 할당한 후 각 요소들의 값을 하나로 결합
  
  ```dart
  List<int> numbers = [1, 2, 3, 4, 5];
  var result = numbers.fold('', (a, b) => '$a' + '$b');
  print(result); // 12345
  print(result.runtimeType); // String
  ```
  > ⚡ **활용 팁**: 초기값 타입과 리턴 타입을 조정하여 새로운 타입으로 형변환 가능

##### ✅ **`any()`**
**Collection 타입의 데이터에 있는 요소 중 하나라도 주어진 조건을 만족**하면 `true`를 반환합니다.
  ```dart
  List<int> numbers = [1, 2, 3, 4, 5];
  var result = numbers.any((number) {
    return number.isEven; // 짝수 여부 확인 (boolean 반환)
  }); // 결과값도 boolean 타입
  print(result); // true
  ```

  ```dart
  List<int> numbers = [1, 2, 3, 4, 5];
  var result = numbers.any((n) => n.isEven);
  print(result); // true
  ```

##### ✅ **`every()`**
**Collection 타입의 데이터에 있는 모든 요소가 주어진 조건을 만족**하면 `true`를 반환합니다.
  ```dart
  List<int> numbers = [1, 2, 3, 4, 5];
  var result = numbers.every((number) {
    return number > 0;
  });
  print(result); // true
  ```
  
  ```dart
  List<int> numbers = [1, 2, 3, 4, 5];
  var result = numbers.every((number) => number > 0);
  print(result); // true
  ```

##### ➡️ **`takeWhile()`**
**Collection 타입의 데이터에서 조건에 맞는 요소를 연속적으로 가져오다가, 조건에 맞지 않는 첫 번째 요소를 만나는 순간 작업을 멈추고 반환**합니다.

  ```dart
  List<int> numbers = [1, 2, 3, 4, 5, 6];
  var result = numbers.takeWhile((number) {
  return number < 4;
  });
  print(result); // (1, 2, 3)
  ```

  ```dart
  List<int> numbers = [1, 2, 3, 4, 5, 6];
  var result = numbers.takeWhile((number) => number < 4);
  print(result); // (1, 2, 3)
  ```

##### ⬅️ **`skipWhile()`**
**Collection 타입의 데이터에서 조건에 맞는 요소를 연속적으로 건너뛰다가, 조건에 맞지 않는 첫 번째 요소를 만나는 순간 작업을 멈추고 이후 모든 요소들을 반환**합니다.

  ```dart
  List<int> numbers = [1, 2, 3, 4, 5, 6];
  var result = numbers.skipWhile((number) {
  return number < 4;
  });
  print(result); // (4, 5, 6)
  ```
  ```dart
  List<int> numbers = [1, 2, 3, 4, 5, 6];
  var result = numbers.skipWhile((number) => number < 4);
  print(result); // (4, 5, 6)
  ```

### 🏢 객체 지향 프로그래밍과 Dart(1) - 클래스와 속성

#### 📊 속성(Properties) 종류

| **속성 종류** | **설명** | **사용법** |
|:---:|:---|:---|
| **인스턴스 변수** | 객체에 속해 있는 변수 | `String name;` |
| **지역 변수** | 특정 코드 블록 안에 선언된 변수 | `void method() { int temp = 5; }` |
| **정적 변수** | 클래스 자체에 속하는 변수 | `static int count;` |

### 🏢 객체 지향 프로그래밍과 Dart(2) - 클래스와 메서드

#### 🔄 메서드 vs 함수

| **구분** | **메서드** | **함수** |
|:---:|:---|:---|
| **소속** | 클래스에 종속 | 클래스와 무관 |
| **호출** | 객체.메서드() | 함수명() |
| **예시** | `car.start()` | `print()` |

#### 📊 메서드 종류

##### 💵 **인스턴스 메서드**
- 객체를 통해 호출되는 메서드
- 인스턴스 변수에 접근 가능

##### ⚡ **정적 메서드**
- 클래스명을 통해 직접 호출
- 인스턴스 생성 없이 사용 가능

##### 🏠 **생성자 (Constructor)**

> ⚠️ **중요**: 인스턴스 변수가 있다면 기본 생성자에서 모두 초기화해야 합니다.

**1️⃣ 매개변수 생성자**
      ```dart
      // Dart만의 간결한 문법
      class Car {
        String name;
        List<String> models;
        
        Car(this.name, this.models);
      }
      ```
      ```dart
      // C++ 스타일 생성자
      class Car {
        String name;
        List<String> models;

        Car(String name, List<String> models)
            : this.name = name,
              this.models = models;
      }
      ```
      ```dart
      // Java 스타일 생성자
      class Car {
        String name = '';
        List<String> models = [];

        Car(String name, List<String> models) {
          this.name = name;
          this.models = models;
        }
      }
    
**2️⃣ 네임드 생성자 (Named Constructor)**

클래스 메서드와 같은 형식으로 호출하는 생성자

```dart
// 문법: [클래스명].[메서드명]([타입] [매개변수명]) : this.변수;
```
      ```dart
      class Car {
        String name;
        List<String> models;

        Car.fromList(List values)
            : this.name = values[0],
              this.models = values[1];
      }
      ```
      ```dart
      class Car {
        String name;
        List<String> models;

        Car.fromList(List values)
            : this.name = values[0],
              this.models = values[1];

        void speakName() {
          print('저희는 $name 입니다 !');
        }

        void speakModels() {
          print('$models 모델을 가지고 있습니다 !');
        }
      }

      void main() {
        Car car = Car.fromList([
          'BMW',
          ['320i', '340i', 'M3']
        ]);
        car.speakName(); // 저희는 BMW 입니다 !
        car.speakModels(); // [320i, 340i, M3] 모델을 가지고 있습니다 !
      }
      ```

#### 🔄 제네릭 클래스

**다양한 타입에 대해 동일한 로직을 적용**할 수 있는 클래스입니다.
  ```dart
  class Box<T> {
    T value;

    Box(this.value);

    T getValue() {
      return value;
    }
  }
  ```

## 객체 지향 프로그래밍과 Dart(3) - 객체 지향과 상속

### 상속

* super 를 통해 자식 클래스 가 부모 클래스 의 속성 과 메서드 를 사용할 수 있어요.
* 자식 클래스 는 상속 받은 속성 과 메서드 를 재정의 (Overriding) 하거나 기능을 확장할 수 있어요.
* 근데요 .. 어떤 클래스 는 상속 당하지 (?) 않게 하고 싶을 때는 final 을 사용하면 돼요
  ```dart
  final class Person {
    void eat() {
      print('냠냠 !');
    }
  }

  class Student extends Person {
    // Error: The type 'Student' must be 'base', 'final' or 'sealed' because the supertype 'Person' is 'final'.
  }
  ```

#### 🔄 **extends vs implements** 


| **구분** | **`extends`** | **`implements`** |
|:---:|:---|:---|
| 🎯 **목적** | 클래스 확장 및 **코드 재사용** | 인터페이스 구현 및 **규격 준수** |
| 💻 **코드** | 부모의 구현된 코드를 물려받음 | 부모의 구현된 코드는 물려받지 않음 |
| ⚖️ **의무** | 메서드 재정의는 선택 사항 | 모든 메서드를 반드시 재정의해야 함 |
| 📊 **개수** | 단일 상속만 가능 | 다중 구현이 가능 |

### ⚠️ 예외 처리로 단단한 코드 만들기

#### 🚨 예외(Exception) 종류
* DeferredLoadException: 필요한 시점에 로드되도록 설정한 라이브러리가 로드되지 못 했을 때 발생해요.
* FormatException: 데이터가 처리 가능한 형태가 아니어서 데이터를 처리하기 어려울 때 발생해요.
* IOException: 입출력 관련 동작을 하는 중에 발생하는 오류 🚨
  * FileSystemException
  * HttpException
  * ProcessException
  * SignalException
  * SocketException
  * StdinException
  * StdoutException
  * TlsException
  * WebSocketException
* OSError: 운영체제 레벨에서 발생하는 오류 🥹
* TimeoutException: 비동기 결과를 기다리는 동안 특정 시간이 초과되었을 때 발생해요.
* 사용자가 직접 정의한 예외:
  ```dart
  class AgeException implements Exception {
    final String? message;
    
    AgeException(this.message);
    
    @override
    String toString() => message ?? 'AgeException 이 발생했어요 !';
  }
  ```

**관련 키워드**

* try
* catch
* on: try 의 코드 블록에서 발생할 수 있는 예외 중 **특정 타입의 예외**를 다루는 부분
  ```dart
  on IOException catch (e) {
    // IOException 이 발생했을 때 실행할 코드
  }
  ```
* finally

### 오류(Error)

**종류**

* ArgumentError
* AssertionError
  ```dart
  void checkAge(int age) {
    assert(age > 0, 'Age must be positive');
  }

  void main() {
    checkAge(-5); // AssertionError 발생
  }
  ```
  ```dart
  assert(text != null);
  assert(number < 100, '100 이상이면 안 돼요 !');
  ```
* RangeError: 허용되지 않는 범위의 값이 매개변수로 전달되었을 때 발생해요.
* IndexError
* NoSuchMethodError: 함수 나 메서드 를 실행할 수 없는 경우에 발생해요.
* OutOfMemoryError
* StackOverflowError
* StateError: 객체의 현재 상태로는 특정 동작 수행이 불가능한 경우에 발생해요.
  ```dart
  List<int> numbers = [];
  print(numbers.first);
  ```
* TypeError
* UnimplementedError
* UnsupportedError: 객체를 통해 실행될 수 없는 동작일 때 발생해요.

#### 🆚 **예외 vs 오류 비교**

| **구분** | **예외 (Exception)** | **오류 (Error)** |
|:---:|:---|:---|
| 🎯 **발생 원인** | 코드가 논리적으로 맞지 않거나 부적절한 값 입력 | 시스템 문제 (메모리 부족 등) |
| 🔮 **예측 가능성** | 예상할 수 있음 | 예상할 수 없음 |
| 🛠️ **처리 가능성** | `try-catch`를 통해 처리 가능 | 발생을 예상할 수 없어 처리 불가능 |
| 📝 **예시** | `FormatException`, `TimeoutException` | `OutOfMemoryError`, `StackOverflowError` |

> 💡 **핵심 포인트**: 예외는 개발자가 예상하고 처리할 수 있지만, 오류는 시스템 레벨의 문제로 예상하기 어렵습니다.


### 📦 라이브러리를 이용해 확장하기

#### 🌐 **모든 플랫폼에서 사용 가능한 라이브러리**
- **`dart:core`**: Dart의 기본 라이브러리 (자동 import)
- **`dart:async`**: 비동기 프로그래밍 지원
- **`dart:collection`**: 컴렉션 타입 추가 기능
- **`dart:convert`**: JSON, UTF-8 등 데이터 변환
- **`dart:developer`**: 디버깅 및 개발 도구
- **`dart:math`**: 수학 관련 함수들

#### 💻 **Native platform에서 사용 가능한 라이브러리**
- **`dart:ffi`**: C API를 사용할 수 있도록 하는 Foreign Function Interface
- **`dart:io`**: 파일 시스템, 네트워크, 프로세스 처리

#### 🌍 **Web platform에서 사용 가능한 라이브러리**
- **`package:web`**: 웹 개발을 위한 기본 라이브러리
- **`dart:js_interop`**: JavaScript와의 상호 작용
- **`dart:html`**: HTML DOM 조작 및 웹 API

#### 🌐 **Dart SDK에 포함되어 있지 않은 외부 라이브러리**

[**Pub.dev**](https://pub.dev)에서 다양한 외부 라이브러리를 쉽게 찾아서 사용할 수 있습니다! 🤩

##### 🔥 **많이 쓰이는 인기 라이브러리**
| **라이브러리** | **기능 설명** |
|:---|:---|
| `cupertino_icons` | iOS 스타일 아이콘 |
| `intl` | 번역, 날짜/숫자 포맷팅 등 국제화 기능 |
| `shared_preferences` | 로컬 데이터 저장 (iOS NSUserDefaults, Android SharedPreferences) |
| `url_launcher` | URL, 이메일, 전화 등 외부 앱 연동 |
| `image_picker` | iOS/Android에서 사진 선택 및 촬영 |
| `firebase_core` & `firebase_auth` | Firebase 서비스 통합 및 인증 |
| `google_fonts` | Google Fonts 사용 |
| `permission_handler` | iOS/Android 권한 관리 |
| `custom_lint` | 커스텀 Lint 규칙 적용 |
| `flutter_svg` | SVG 이미지 렌더링 |
| `cached_network_image` | 네트워크 이미지 캐싱 |
| `flutter_local_notifications` | 로컬 알림 기능 |
| `path_provider` | 시스템 디렉토리 경로 제공 |
| `geolocator` | GPS 위치 정보 처리 |
| `dio` | 강력한 HTTP 클라이언트 라이브러리 |

> 📝 **참고**: pub.dev에 있는 외부 라이브러리를 가져올 때 `package:` 접두사가 붙습니다.

#### 🔧 **라이브러리 사용 특징**

##### 🏷️ **별칭(Alias) 사용**
```dart
import 'package:http/http.dart' as http;
```

##### 🎯 **선택적 Import (show)**
```dart
import 'package:lib1/lib1.dart' show foo;
```

##### 🚫 **제외 Import (hide)**
```dart
import 'package:lib2/lib2.dart' hide foo;
```

##### ⏳ **지연 로딩 (deferred as)**

> ⚠️ **주의**: 모든 플랫폼에서 지원하지 않으며, **Web platform에서만** 지원합니다.

```dart
import 'package:greetings/hello.dart' deferred as hello;

Future<void> greet() async {
  await hello.loadLibrary();
  hello.printGreeting();
}
```

### ⏱️ 비동기 프로그래밍과 Dart

**시간이 오래 걸리는 작업**인 경우 결과값이 나오는 동안 CPU 블럭을 막기 위해서 비동기 동작을 실행하여 **효율성을 향상**시킵니다.

#### 📊 **비동기 프로그래밍이 필요한 경우**

- 📁 **파일로부터 데이터를 읽을 때**
- 💾 **데이터베이스에 데이터를 쓸 때**
- 🌐 **네트워크를 통해 데이터를 불러올 때**

#### 🔮 **Future**

**작업이 성공적으로 완료되었을 때 해당 결과값을 반환**하고, 실행을 종료하는 일회성 비동기 작업입니다.

```dart
Future<String> introduce(String name) async {
	print('$name의 자기소개 시작 !');
  
  await Future.delayed(Duration(seconds: 2), () {
    print('안녕 ? 나는 $name ~');
  });
	
	print('$name의 자기소개 끝 !');
  
  return '이름은 $name ~';
}

void main() async {
  var riverfuture = await introduce('강미래');
  var riverpresent = await introduce('강현재');
  print('나의 $riverfuture 너의 $riverpresent');
}

/*
강미래의 자기소개 시작 !
안녕 ? 나는 강미래 ~
강미래의 자기소개 끝 !
강현재의 자기소개 시작 !
안녕 ? 나는 강현재 ~
강현재의 자기소개 끝 !
나의 이름은 강미래 ~ 너의 이름은 강현재 ~
*/

## 💻 실습 및 예제

위에서 학습한 내용들은 모두 **실제 코드 예제**와 함께 제시되어 있어 바로 실습해볼 수 있습니다.

## 📝 마무리

### ✅ 오늘 배운 것
- **함수형 프로그래밍**: `map()`, `where()`, `reduce()`, `fold()` 등 고차 함수들의 활용법
- **객체 지향 프로그래밍**: 클래스, 속성, 메서드, 상속의 개념과 구현 방법
- **예외 처리**: Exception과 Error의 차이점과 `try-catch` 구문 사용법
- **라이브러리**: Dart 내장 라이브러리와 외부 패키지 활용법
- **비동기 프로그래밍**: `Future`와 `Stream`의 기본 개념과 활용법

### 🚀 다음 계획
- **고급 비동기 프로그래밍**: `async`/`await` 패턴 심화 학습
- **Flutter 위젯**: Dart 지식을 바탕으로 한 Flutter UI 구현
- **상태 관리**: Provider, Riverpod 등 상태 관리 패턴 학습
- **실전 프로젝트**: 학습한 개념들을 활용한 실제 앱 개발
```

> ⚠️ **Future의 한계** 🥺
> - 하나의 작업당 **결과값을 1번만** 받을 수 있습니다 (일회용)
> - 하나의 작업에 결과값이 여러 번 나오는 경우가 있을 수 있습니다!
> - 이러한 한계를 극복하기 위해 **`Stream`**이 등장합니다! 🚀

#### 🌊 **Stream**

**시간에 따라 연속적인 데이터 흐름을 제공**합니다.
**한 번에 하나의 값이 아닌 여러 값을 비동기적으로 받을 수 있습니다.**

> 💡 **Future vs Stream**: Future는 단일 결과, Stream은 연속적인 다중 결과를 처리!

```dart
Stream<int> emitNumbers(int first) async* {
  for (var i = first; i >= 0; i--) {
    yield i;
    
    await Future.delayed(Duration(seconds: 1));
  }
}

void main() {
  emitNumbers(10).listen((number) {
    print(number);
  });
}

/*
10
9
8
7
6
5
4
3
2
1
0
*/
```