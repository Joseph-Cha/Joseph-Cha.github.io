---
title: "📚 Today I Learned 22회차 - Dart Factory 생성자 🏭"
date: 2025-10-21T00:00:00-00:00
categories:
  - TIL
  - Dart
tags:
  - TIL
  - Dart
  - Factory
  - Flutter
  - 생성자
---

안녕하세요! 오늘은 Flutter 개발자들이 데이터 모델을 다루거나 디자인 패턴을 구현할 때 필수적으로 사용하는 Dart 언어의 특별한 생성자 키워드, **`factory`**에 대해 정리해 보겠습니다.

일반적인 생성자와 `factory` 생성자는 겉보기엔 비슷하지만, 내부적으로는 객체를 생성하는 방식과 역할에 큰 차이가 있습니다.

## 🎯 학습 목표

- **Factory 생성자의 개념**과 일반 생성자와의 차이점 이해하기
- **Factory 생성자를 사용하는 3가지 핵심 이유** 학습하기
- 싱글톤 패턴, JSON 파싱, 서브클래스 반환 등 **실제 활용 사례** 파악하기
- Factory 생성자를 활용한 **실전 코드 작성** 익히기

## 📚 주요 내용

### 📖 1. `factory`란 무엇인가?

`factory` 생성자는 **새로운 인스턴스를 생성하는 과정을 직접 제어**할 수 있는 생성자입니다. 이는 생성자처럼 보이지만, 실제로는 해당 클래스 인스턴스를 반환하는 **정적 메서드(Static Method)**와 유사하게 작동합니다.

> 💡 **핵심 포인트**: 일반 생성자와 달리, `factory` 생성자는 호출될 때 **반드시 새 인스턴스를 생성할 의무가 없다**는 점입니다.

### ⭐ 2. `factory`를 사용하는 결정적인 이유 3가지

`factory` 키워드가 없다면 해결하기 어렵거나 비효율적인 상황들이 있습니다.

#### ① 인스턴스 캐싱 및 싱글톤 구현 (객체 재활용) ♻️

메모리 효율이 중요할 때, 동일한 객체를 매번 새로 만드는 대신 이미 존재하는 객체를 재사용할 수 있습니다.

* **일반 생성자:** 호출될 때마다 무조건 새 객체 생성.
* **`factory` 생성자:** 내부 로직을 통해 이미 생성된 인스턴스(예: 싱글톤 인스턴스)가 있는지 확인하고, 있다면 **새로 만들지 않고 기존 인스턴스를 반환**합니다.

#### ② 외부 데이터(JSON) 처리 및 복잡한 초기화 로직 ⚙️

외부 데이터(특히 **JSON Map**)를 클래스 객체로 변환하는 과정은 데이터 검증, 타입 변환(`int` -> `double`), 기본값 할당 등 복잡한 로직을 요구합니다.

* **일반 생성자**: 복잡한 로직을 생성자에서 처리하기 어렵고, `return` 문을 사용할 수 없어 유연성이 떨어집니다.
* **`factory` 생성자**: 함수 본문 내에 `if/else`와 같은 **모든 제어 흐름 및 로직을 구현**할 수 있습니다. 이를 통해 데이터가 **누락되거나 잘못된 타입으로 들어왔을 때** 안전하게 처리 후 **명시적으로 `return`**할 수 있습니다.

> 💡 **실제 활용 사례**: `Product.fromJson`과 같은 패턴에서 `json['key'] ?? '기본값'` 또는 타입 캐스팅을 통해 안전한 객체 생성이 가능합니다.

#### ③ 조건부 서브클래스 인스턴스 반환 (추상화) 🧱

팩토리 생성자는 호출된 클래스 자체가 아닌, 해당 클래스를 상속받은 다른 구체적인 **서브클래스의 인스턴스**를 반환하도록 할 수 있습니다.

* **예시**: 상위 추상 클래스의 `factory` 생성자를 호출했을 때, 입력된 조건(파라미터)에 따라 자식 클래스(`Circle`, `Square` 등) 중 하나를 선택하여 반환함으로써 **생성 로직을 추상화**할 수 있습니다.

### 📊 3. 일반 생성자 vs Factory 생성자 비교

| **구분** | **일반 생성자** | **`factory` 생성자** |
|:---:|:---|:---|
| **객체 생성** | 항상 새 인스턴스 생성 | 기존 인스턴스 반환 가능 |
| **핵심 역할** | 필드 초기화 | 생성 프로세스 제어 및 관리 |
| **키워드** | 없음 | `factory` |
| **메서드 본문** | 제한적 (초기화 리스트) | 자유로운 로직 및 `return` 사용 가능 |
| **반환 타입** | 현재 클래스만 | 서브클래스 반환 가능 |

## 💻 실습 및 예제

### 🔧 예제 1: 싱글톤 패턴 구현

```dart
// 싱글톤 패턴 - 앱 전역에서 하나의 인스턴스만 사용
class Logger {
  static final Logger _instance = Logger._internal();

  // Private 생성자
  Logger._internal();

  // Factory 생성자 - 항상 동일한 인스턴스 반환
  factory Logger() {
    return _instance;
  }

  void log(String message) {
    print('[LOG] $message');
  }
}

void main() {
  var logger1 = Logger();
  var logger2 = Logger();

  // 동일한 인스턴스인지 확인
  print(identical(logger1, logger2)); // true
  logger1.log('싱글톤 패턴 테스트'); // [LOG] 싱글톤 패턴 테스트
}
```

### 🔧 예제 2: JSON 데이터 파싱

```dart
// JSON 데이터를 안전하게 객체로 변환
class Product {
  final String name;
  final double price;
  final String category;

  Product({
    required this.name,
    required this.price,
    required this.category,
  });

  // Factory 생성자로 JSON 파싱 및 검증
  factory Product.fromJson(Map<String, dynamic> json) {
    // 데이터 검증 및 기본값 처리
    return Product(
      name: json['name'] ?? 'Unknown Product',
      price: (json['price'] ?? 0).toDouble(), // int를 double로 변환
      category: json['category'] ?? 'General',
    );
  }
}

void main() {
  // 정상 데이터
  var product1 = Product.fromJson({
    'name': 'Flutter Book',
    'price': 25000,
    'category': 'Books'
  });

  // 불완전한 데이터 - 기본값으로 안전하게 처리
  var product2 = Product.fromJson({'name': 'Widget'});

  print('${product2.name}, ${product2.price}, ${product2.category}');
  // 출력: Widget, 0.0, General
}
```

### 🔧 예제 3: 조건부 서브클래스 반환

```dart
// 추상 클래스
abstract class Shape {
  void draw();

  // Factory 생성자 - 타입에 따라 다른 서브클래스 반환
  factory Shape(String type) {
    if (type == 'circle') {
      return Circle();
    } else if (type == 'square') {
      return Square();
    }
    throw ArgumentError('Unknown shape type: $type');
  }
}

class Circle implements Shape {
  @override
  void draw() {
    print('○ 원을 그립니다');
  }
}

class Square implements Shape {
  @override
  void draw() {
    print('□ 사각형을 그립니다');
  }
}

void main() {
  // 동일한 생성자 호출이지만 다른 타입의 객체 반환
  Shape shape1 = Shape('circle');
  Shape shape2 = Shape('square');

  shape1.draw(); // ○ 원을 그립니다
  shape2.draw(); // □ 사각형을 그립니다
}
```

## 🔍 심화 학습

### 🤔 Factory 생성자 활용 팁

**1. 캐싱 최적화**
- 자주 사용되는 객체는 `Map`에 저장하여 재사용
- 메모리 효율성 향상

**2. 불변 객체와의 조합**
- `const` 생성자와 함께 사용하여 컴파일 타임 상수 활용
- 성능 최적화 가능

**3. 네이밍 컨벤션**
- `fromJson`, `fromMap`: 데이터 변환용
- `create`, `build`: 복잡한 생성 로직용

> ⚠️ **주의사항**: Factory 생성자는 강력하지만 과도한 사용은 코드 복잡도를 높일 수 있습니다. 단순한 경우에는 일반 생성자를 사용하는 것이 더 명확할 수 있습니다.

## 📝 마무리

### ✅ 오늘 배운 것

- **Factory 생성자의 핵심**: 객체 생성 과정을 제어하며, 항상 새 인스턴스를 만들 필요가 없음
- **3가지 주요 활용 사례**:
  - ♻️ **싱글톤 패턴**: 메모리 효율적인 인스턴스 재사용
  - ⚙️ **JSON 파싱**: 안전한 데이터 변환 및 검증
  - 🧱 **서브클래스 반환**: 유연한 객체 생성 패턴
- **일반 생성자와의 차이**: Factory는 `return` 문과 복잡한 로직 사용 가능
- **실전 코드**: Logger 싱글톤, Product.fromJson, Shape 팩토리 패턴 구현

### 🚀 다음 계획

1. **Freezed 패키지**: Factory 생성자를 자동으로 생성해주는 코드 생성 라이브러리 학습
2. **디자인 패턴 심화**: Factory Method 패턴, Abstract Factory 패턴 적용
3. **불변 객체(Immutable)**: `const` 생성자와 Factory의 조합으로 성능 최적화
4. **실전 프로젝트**: API 응답 데이터 모델링에 Factory 생성자 적용하기